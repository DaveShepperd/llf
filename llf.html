<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
<!--    <link rel="stylesheet" href="style.css"> -->
    <title>LLF</title>
  <style>
  table {
    border-collapse: collapse;
    width: 50%;
  }
  
  th, td {
    text-align: left;
    padding: 2px;
  }
  
  tr:nth-child(even) {
    background-color: #D6EEEE;
  }
  .TblCntr table
  {
		margin: 10px;
		border:1px solid #000;
    border-collapse: collapse;
    width: 50%;
    align: left;
  }
  .TblCntr tr
  {
    border: 2px solid white;
  }
  .TblCntr th
  {
    border: 2px solid white;
    text-align: center;
    padding: 2px;
  }
  .TblCntr td
  {
    border: 2px solid white;
    text-align: center;
    padding: 2px;
  }
  .TblCntr tr:nth-child(even)
  {
      background-color: #D6EEEE;
  }
  </style>
  </head>
  <body>
  <div style="width: 25%;text-align:center;">
  <h1>LLF</h1>
  LLF a Link Locate and Formatter<br>
  Version 10.7<br>
  First generation, LINKM, was created in 1976 in PDP11 assembly<br>
  Rewritten in C, this kit, in the early 1980's<br>
  Revisions through Aug 2022 on this version<br>
  </div>
  <p></p>
  <div style="border: 2px solid black;margin:4px;padding: 4px">
  <em>Note from Dave Shepperd, 8/2022
  <p>
  There never were any release notes kept on this application so there is no record of what got changed when. It just is what it is.
  I wrote the PDP11/RT11 version in the late 1976 and the current C version in probably 1982 or 1983. It continued to get development until the late 1990's
    and continues to get bug fixes to this day.
    </p>
    <p>
    Recently I got involved in rebuilding some of old Atari coin-op game code (some of which recently
    was released on github) and wanted to use this tool to make ROM/EPROM images and to test them with MAME. This prompted me to port the documentation,
    what little there is, of the three main applications used to build game images to HTML. Those tools are the assembler
    (<a href="https://github.com/DaveShepperd/macxx.git" target="_blank">MACXX</a>),
    linker (<a href="https://github.com/DaveShepperd/llf.git" target="_blank">LLF</a>, this tool)
    and rom image maker (<a href="https://github.com/DaveShepperd/mixit.git" target="_blank">MIXIT</a>).
    Although I wrote the original documentation for this linker (llf.doc, the basis for this html document),
    I am neither a technical writer nor am I any good at HTML5. As might be evidenced
    with the original documentation, I quickly lose interest in writing technical documents and don't check things too closely. So good luck
    making sense of anything written here. Feel free to hack this document into something more readable. If you do, please send me a copy.
  </p>
    <p>If one cares, I wrote a little history about how this linker and the other two tools came to be. It can be found
    <a href="#history">HERE</a>.
    </p>
  </em>
  <p>
    <em>NOTE: There may be some obscure bug in these sources somewhere where if you build it as a 64 bit application, it
  makes some obscure mistake. I'm not sure about this, I've only heard about it from someone who complained. I haven't
  looked into it further.<br> It was just too easy to build with <u>-m32</u> and forget about it. User beware.
    </em>
  </p>
  </div>
  <p>
  Working on docs. Look here later.
  </p>
  <h2 id="Operating">Running LLF</h2>
<p>
To run this utility on a Linux/Unix system:
  </p>
  <pre>
    $ llf [options ...] [inputFile ...] [options ...]
  </pre>
  <p>	
There can be any number of inputFiles limited only by the shell. The input
files may be either .obj, .ol, .ob, .ln, .lb, .stb, .opt or .lib
format (either such as produced by compiliers and/or macxx assembler or in the
  case of .opt, a text editor).
The file format is identified by the
file type characters:
  </p>
  <pre>
     .obj  - indicates the old RT11 object file format (.LDA type).
     .ol   - indicates the ASCII format (default if no type on input file)
     .ob   - indicates the binary equivalent of .ol
     .ln   - the same as .ol (previously llf'd)
     .lb   - indicates the binary equivalent of .ln
     .stb  - the same as .ob and .lb except symbols only
     .opt  - indicates an option file
     .lib  - indicates a library file
  </pre>
  <p>
Library and Option files can also be provided via the command line options
  -opt=file and -lib=file respectively.
</p>
 <p>
Only the first 5 characters are significant on any of the options,
although any of them may be abbreviated to 1 or more characters.
</p>
<p>
The -options can appear anywhere on the command line. The items listed
in []'s are optional arguments to the particular option. Where option
is one of ([] implies optional text):
</p>
<pre id="Options">
  -[no]output[=name]   - select and name output file
  -[no]map[=name]      - select and name map file
  -[no]symbol[=name]   - select and name symbol file
  -[no]stb[=name]      - select and name symbol table file
  -option[=name]       - names an input option file
  -library[=name]      - names an input library file
  -[no]binary          - select binary format output file
  -[no]cross           - select cross reference map file format
  -[no]octal           - select octal map file format
  -[no]obj             - select default input file type of .ob
  -[no]relative        - select relative output file format
  -[no]error           - force display of undefined symbols in -relative mode
</pre>
<p>
Defaults are -out -nomap -nosym -nostb -bin -nocross
             -nooctal -noobj -norel -noerr
</p>
<p>
The output filename defaults to the same name as the first input file with
output format and file types according to the following:
</p>
  <table style="width: 20%">
    <tr><th>Extension</th><th>Selected options</th></tr>
    <tr><td>.vlda</td><td>-bin and -norel</td>
    <tr><td>.lb</td><td>-bin and -rel</td>
    <tr><td>.hex</td><td>-nobin and -norel</td>
    <tr><td>.ln</td><td>-nobin and -rel</td>
  </table>
  <p>
The -map, -symbol and -stb files default to the same name as the -output file
with file types of .map, .sym and .stb respectively.
  </p>
  <p>
The command options descriptions:
  </p>
  <p id="opt_cross">
-cross - Cross references the global symbols used by filename and
	lists them in the map file. Forces the -map option. In the filename
	list, the first file listed is the one that defined the symbol
	unless the symbol was undefined (indicated by a message).
</p>
  <p id="opt_binary">
-binary - Forces the output file format to be written in a special binary
	format.
  </p>
  <p id="opt_obj">
-obj - causes the default input file type to be .ob instead of .ol.
	That is, files are first attempted to be opened with a file type of
	.ob and if a file-not-found condition exists, then they are again
	attempted to be opened with a default file type of .ol.
  </p>
  <p id="opt_relative">
-relative - Output file is in a relative format. That is, the segments are
	not located and global symbols may not be completely resolved. If
	this option is selected, then the default output file type is changed
	from .hex to .ln. The output can be run through LLF again to do the
	final locate and format. If -binary is present, then the default
	changes to .lb.
  </p>
  <p id="opt_error">
-error - Forces LLF to display undefined symbol and other messages that would
	normally be suppressed during a -relative link. Use this if you need
	a relative output but are not intending to re-link the output with
	additional object modules or just want to be informed of any unresolved
	global references.
  </p>
  <p id="opt_output">
-output[=name] - Allows you to specify an output file name that may be
    different than the input filename(s). This option is defaulted and
	the filename used is the same as the first non-library or non-option
	file input. Note that the file is created in the current default
	directory and not necessarily the directory that the input file(s)
	are located in.
 </p>
  <p id="opt_map">
-map[=name] - Specifies that LLF create a printable MAP file with the output
    image statistics (such as segment placement and global symbol values).
	The optional value allows for filename to be specified if different
	than that of the output filename. Note that segment and symbol names
	may be 32 characters in length but the rightmost characters may
	be truncated on the link map in order to make a reasonable display
	format. All the characters remain significant for linking purposes
	regardless of what is displayed on the link map.
 </p>
  <p id="opt_octal">
-octal - Specifies that all the values displayed in error messages and on the
	link map be done using an octal radix. The segment and symbol name
	fields may be further truncated to accomodate the longer length of
	the 32 bit octal numbers.
 </p>
  <p id="opt_symbol">
-symbol[=name] - Specifies that global symbols and their values should be
    placed in the output file. If an optional value is placed on this
	option, then a seperate file will be created with only the global symbols
	in it. The symbol file will be created in tekhex format unless the
	-binary option is present, in which case, the output will be in .ob
	format. May not be used with the -relative option.
 </p>
  <p id="opt_stb">
-stb=[name] - Creates a segment/symbol file that may be used in a later link
    step. This file would contain only the resolved globals and located
	segments. No code (user data) is placed in this file. (Functionally
	identical to a -symbol file except that the STB file is suitable to
	be used as input to LLF again where the -symbol files may be
	TekHex files suitable only for downloading). May not be used with
	the -relative option.
</p>
  <p id="opt_library">
-library=name - Specifies the name of a library file. Libraries are
	processed in the order that they are encountered. If there are no
	undefined globals at the time the library file is processed, then no
	modules will be plucked from the library. If one or more modules are
	plucked from the library, then the library will be continually
	re-processed until no symbols are resolved by any module(s) in the
	library.
</p>
  <p id="opt_option">
-option=name - Specifies the name of an option file. An option
	file is an ASCII file that you can use to define global symbols and
	locate segments and other specifics. The syntax of the OPTION file
	follows.
</p>
  <h3 id="option_file">Option file contents</h3>
  <p >
        The contents of the option file is used to define global symbols
        and set the locations of sections and other memory operations. It
        uses basically the same rules as the "C" language in that white
        space consists of spaces, tabs and newlines. White space must
	seperate names from other names but otherwise is ignored. Comments
	can appear on any line and are de-limited with double dashes (--)
	or exclamation mark (!) and a newline. The C comment construct of "/*"
	and "*/" can also be used. The case of any of the keywords is <b>NOT</b>
	significant, but the case of the segment and global names <b>IS</b>
	significant. Numbers are assumed to be decimal unless prefixed with a
	pound sign (#) or '0x' which indicates hexidecimal. The C constant
	declaration may also be used. That is constants are assumed to be decimal
	unless preceeded with a leading 0, in which case, they are octal or
	preceeded with a 0x to indicate hexidecimal. The main keyword (FILE,
	LOCATE, etc.) is expected to be the first token on a newline and
	everything after the closing parantheses to end of line is discarded.
	Some examples:
</p>
  <pre>
  FILE ( filename1 filename2 ... )   /* includes file(s) for input */
  LIBRARY ( library1 library2 ... )  /* includes library(s) for input */
  </pre>
<p>
	As with the command input, the default input file types are assumed to
	be .ol or .ob and the default library file type is .LIB. Filenames
	may be delimited with either commas (,) or white space and the files
	and libraries are processed in the order in which they are specified
	and in the same order as the option file is input in the command
	string. For example: 
</p>
  <pre>
      $ llf one two.opt three
  </pre>
<p>
	where two.opt contains:
</p>
  <pre>
      FILE (four five)
      LIBRARY (six)
      FILE (seven)
  </pre>
<p>
	will cause the files to be processed as "one two four five six.lib seven three". 
</p>
  <h3 id="option_locate">LOCATE option</h3>
  <pre>
  LOCATE ( group_name : address_option ; ... )       !position a group or segment
  LOCATE ( segment_name ... : address_option ; ... ) !at a specific address 
                                                     !    or range of addresses
  </pre>
<p>
	Where "group_name" refers to the name of a group and "segment_name"
	refers to the name of a segment or section (there's no difference
	between a section and a segment). The "address_option" can be one of
	the following:
</p>
  <pre>
      constant [additional_argument(s)]
  </pre>
<p>
	Where "constant" is assumed to be a number and "additional_arguments"
	can be one or more of the following:
</p>
  <pre>
      TO constant
      OUTPUT constant
      NAME group_name
  </pre>
<p>
	The "TO constant" construct instructs LLF to notify you if the
	segment(s) you locate won't fit in the area specified. The
	"OUTPUT constant" construct allows you to locate the segment(s)
	at one address but place the data in a different area in the
	output address space. The "NAME" option allows you to name a
	group with other than the automatic "noname_xxx" name generator.
	Examples: 
</p>
  <pre>
      LOCATE ( DEFAULT_GROUP       : #1000 );
      LOCATE ( $$one $$two $$three : #0100;
               $$four $$five $$six : #0200 TO #02FF;
               $code               : #8000 TO #DFFF OUTPUT #10000;
               $tables1 $tables2   : #0C000 OUTPUT #1C000);
  </pre>
  <p>
  What would happen with the above options is all the segments in DEFAULT_GROUP would be located starting at 0x1000. Segments $$one, $$two and $$three would be concatenated
  in that order and the collection located starting at 0x100. The segments $$four, $$five and $$six would be concatenated in that order and located
  starting at location 0x200 and an error will be emitted if they have grown over 0x2FF (that is, overlapped into 0x300). The segment $$code is located
  beginning at location 0x8000 and cannot overlap into 0xE000 but the contents is placed in the output file starting with addresses 0x10000. The segments
  $tables1 and #tables2 are concatenated and located at 0xC000 but they are placed in the output file starting with addresses 0x1C000.
  </p>
<h3 id="option_declare">DECLARE option</h3>
  <pre>
    DECLARE ( symbol_name value, ...) !to define a global symbol
  </pre>
  <p>
	Where "symbol_name" is the global symbol you're defining and value
	is the value to assign to the symbol. You cannot re-define an already
	defined symbol nor can you create a symbol that isn't referenced in
	any of the input files. Examples:
  </p>
  <pre>
      DECLARE ( checksum #0123, FIVE 5, TEN 10 )
  </pre>
<h3 id="option_reserve">RESERVE option</h3>
  <pre>
  RESERVE ( address_option ... )  !to reserve an area of memory such that
                                  !no segments will be placed there by the
                                  !automatic placement mechanism.
  </pre>
<p>
	Where "address_option" is any of the following:
</p>
  <pre>
    constant              /* a specific single location */
    BEFORE constant       /* all addresses below constant */
    AFTER constant        /* all addresses above constant */
    constant TO constant	/* all locations between the 2 constants */
  </pre>
<p>
	Examples:
	</p>
  <pre>
      RESERVE ( 0 TO #0FFF )    /* 0 to 0xFFF inclusive */
      RESERVE ( 0x0630 )        /* location 0x630 only */
      RESERVE ( AFTER 0100000 ) /* 0x8000-0xFFFFFFFF inclusive */
      RESERVE ( BEFORE #0FFF )  /* 0-0xFFF inclusive */
  </pre>
  
  <h2 id="misc">Gotchas</h2>
<p>
RT-11/RSX object files allow for global symbols and PSECTs to have the same name
and yet treat them differently. The OL format does not distinguish between
global symbol names and segment names. In order to allow both formats to
co-exist, LLF suffixes an underscore on all PSECT names defined in the RT/RSX
object files. In addition, the RT/RSX object files may have unnamed psects (the
default blank program section). LLF renames the "blank" psect as "unnamed_"
(notice that it's lowercase). If you choose to locate specific psects to
specific areas, you'll need to reference them using LLF's naming convention.
Notice also that the use of .ASECT, .PSECT xx,ABS and/or .PSECT xx,BSE may
result in warnings about segments being overlayed. This is because the BSE
section(s) may be overlaying the .ASECT or .PSECT xx,ABS sections. 
</p>
  <h2 id="out_formats">Output file formats</h2>
  <h3 id="out_tekhex">Extended TekHex (.hex) format</h3>
<p>
Extended TEKhex (.hex) format is an ASCII record containing one of the following:
</p>
  <pre>
    %nnTcs...
  </pre>
<p>
where:	% is the ASCII percent character (record sentinel).<br>
	nn- is a 2 hex digit count of the number of bytes in the
	     record excluding the percent character.<br>
	T  - is the record type: 3 for symbol, 6 for data and
	     8 for end of file (termination record will not have
	     any data).<br>
	cs - is a 2 digit hex number representing the sum, mod 256,
	     of all the characters in the record, except the leading
	     %, the checksum digits, and the end of line.<br>
</p>
  <p>
In Extended TEKhex, certain fields may vary in length from 2 to 17
characters. This enables data compression by eliminating leading zeroes
from numbers and trailing spaces from symbols. The first character of a
variable length field is the length of the rest of the field. The digit
0 indicates a length of 16 characters. There will be a variable number
of these variable length fields following the checksum and their content
varies according to the record type: 
</p>
  <pre>
    %nn6cslldd... - Data block
      ll    = 2-9 chars of load address
      dd... = n pairs of chars of hex data
  </pre>
<pre>
    %nn8csll   - termination record
      ll = 2-9 chars of transfer address
</pre>
<pre>
    %nn3ccvvss... - symbol record
      vv = 2-17 chars of section name (LLF always writes 2S_)
      ss = n x 5-27 chars of symbol definition:
        1 char of symbol type (LLF always outputs an 
          ASCII 2 = global scalar)
        2-17 chars of symbol name
        2-9 chars of symbol value (LLF resolves to 32 bits)
</pre>
<h3 id="out_vlda">VLDA (.VLDA) format</h3>
  <p>
  This format was formed as a deviation of the RT11 .LDA format once
  we started using the VAX. The <b>V</b> in VLDA was for VAX version
  of LDA.
  </p>
  First byte after count
	identifes the record type. A value of 0 means the data is
	binary load data. A value of 13 (decimal) means data is
	transparent. That is, the text of the record (bytes 1-n)
	are unspecified and are to be passed through unchanged.
	This is typically used for symbol data records. All other
	record types are ignored (these are object file format
	records which should be irrelavent. For type 0 record,
	bytes 1-4 are the target memory address and bytes 5-n
	are the data. I.e.:
  </p>
    <pre>
		Bytes in file increasing this way --->
		(c0 c1)00 a0 a1 a2 a3 dd ... dd
		|    |  |  |  |  |  |  |______|___ (count - 5) bytes of data
		|    |  |  |__|__|__|_____________ Address, least significant byte first
		|    |  |_________________________ Record type 0
		|____|____________________________ count of bytes in record (these bytes are not on VAX)
    </pre>
<h3 id="output_ol">OL and LN output formats</h3>
  <p>
  Look here sometime later.
  </p>
<h3 id="output_ob">OB, LB and .STB output formats</h3>
  <p>
  Look here sometime later.
  </p>
  <h2 id="history">A Little History</h3>
  <div>
    <em>
  <p>
   LLF was written to replace the RT11 linker, LINKM, we had been using since about 1977 as well as the three utilities Link, Locate and Format
   we at Atari coin-op were using with our 68000 cross development tools beginning sometime in the mid 1980's. We picked up the newly available
   C compiler for VAX/VMS (finally) so I chose to write LLF in C. That made it easy to port it to the myriad of non-VAX systems we were using
   at the time and started us on the path of future proofing our development tools. Besides that, the Link, Locate and Format tools were closed
   source either from Greehills or Intermetrics and when run on the VAX were painfully slow. One poor soul had a project where just those three tools
   alone took several hours to build their one project on their VAX 750 so it was an overnight task and a once per day build for them. We didn't
   have that particular problem with any of our projects but it was clear those tools needed some work.
    </p>
    </em>
  </div>
 </body>
</html>
